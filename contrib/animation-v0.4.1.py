#!/usr/bin/env python3
"""
Stop-motion animation for gpal v0.4.1 model upgrade announcement.

Created on Valentine's Day 2025 by Amy Tobey and Claude (Opus 4.6).
The TTS narration was generated by gpal's own `generate_speech` tool
using Gemini 2.5 Pro TTS ‚Äî one of the new features being announced!

Rendering pipeline:
  1. Python generates 276 SVG frames (12fps √ó 23s) programmatically
  2. rsvg-convert rasterizes each SVG ‚Üí PNG (parallelized across 32 cores)
  3. ffmpeg assembles the PNG sequence + WAV audio ‚Üí H.264 MP4

The stop-motion aesthetic comes from per-frame random jitter (¬±1-2px position
offset) and wobble (¬±1¬∞ rotation) on all elements, with deterministic seeds
so the animation is reproducible. Bounce easing with overshoot gives elements
a playful entrance.

Run:
    python contrib/animation-v0.4.1.py

Requires: rsvg-convert (librsvg), ffmpeg, Python 3.10+
Produces: gpal-v0.4.1.mp4 (1080√ó1080, ~1.1MB)
"""

import math
import os
import random
import subprocess
import sys
from concurrent.futures import ProcessPoolExecutor, as_completed
from pathlib import Path

# === Constants ===
WIDTH, HEIGHT = 1080, 1080
FPS = 12
DURATION = 23.0
TOTAL_FRAMES = int(FPS * DURATION)  # 276

FRAMES_DIR = Path("frames")
AUDIO_PATH = Path("test-pro-tts.wav")
OUTPUT_PATH = Path("gpal-v0.4.1.mp4")

# Seed for reproducible jitter (but different per frame)
random.seed(42)
JITTER_SEEDS = [random.randint(0, 999999) for _ in range(TOTAL_FRAMES + 1)]

# === Color Palette ===
# Pastel gradient backgrounds per scene
COLORS = {
    "bg_top_1": "#FFB6C1",     # light pink
    "bg_bot_1": "#FFE4B5",     # moccasin
    "bg_top_2": "#B5D8FF",     # light blue
    "bg_bot_2": "#E8D5FF",     # light lavender
    "bg_top_3": "#D5FFD5",     # light green
    "bg_bot_3": "#FFF5BA",     # light yellow
    "bg_top_4": "#FFE8A1",     # banana yellow
    "bg_bot_4": "#FFD1DC",     # pink
    "bg_top_5": "#E8D5FF",     # lavender
    "bg_bot_5": "#FFB6C1",     # pink
    "card_bg": "#FFFFFF",
    "card_stroke": "#333333",
    "text_dark": "#2D2D2D",
    "text_accent": "#FF6B6B",
    "text_code": "#4A90D9",
    "sparkle": "#FFD700",
    "lightning": "#FFA500",
    "speed_line": "#FF4444",
    "glow_tts": "#7B68EE",
    "banana_yellow": "#FFE135",
    "banana_brown": "#8B6914",
}


# === Easing Functions ===

def ease_bounce(t: float) -> float:
    """Overshoot bounce easing: goes past 1.0 then settles."""
    if t < 0:
        return 0.0
    if t > 1:
        return 1.0
    # overshoot elastic-ish
    return 1.0 - math.cos(t * math.pi * 0.5) * (1.0 - t) + 0.15 * math.sin(t * math.pi * 2) * (1.0 - t)


def ease_in_out(t: float) -> float:
    """Smooth ease in-out."""
    t = max(0.0, min(1.0, t))
    return t * t * (3 - 2 * t)


def ease_out_back(t: float) -> float:
    """Ease out with slight overshoot."""
    t = max(0.0, min(1.0, t))
    c1 = 1.70158
    c3 = c1 + 1
    return 1 + c3 * pow(t - 1, 3) + c1 * pow(t - 1, 2)


def lerp(a: float, b: float, t: float) -> float:
    return a + (b - a) * max(0.0, min(1.0, t))


def lerp_color(c1: str, c2: str, t: float) -> str:
    """Lerp between two hex colors."""
    t = max(0.0, min(1.0, t))
    r1, g1, b1 = int(c1[1:3], 16), int(c1[3:5], 16), int(c1[5:7], 16)
    r2, g2, b2 = int(c2[1:3], 16), int(c2[3:5], 16), int(c2[5:7], 16)
    r = int(r1 + (r2 - r1) * t)
    g = int(g1 + (g2 - g1) * t)
    b = int(b1 + (b2 - b1) * t)
    return f"#{r:02x}{g:02x}{b:02x}"


# === Jitter & Wobble ===

def jitter(frame: int, element_id: int = 0, amount: float = 1.5) -> tuple[float, float]:
    """Deterministic per-frame jitter."""
    rng = random.Random(JITTER_SEEDS[frame] + element_id * 7)
    return rng.uniform(-amount, amount), rng.uniform(-amount, amount)


def wobble(frame: int, element_id: int = 0, max_deg: float = 1.0) -> float:
    """Slight rotation wobble."""
    rng = random.Random(JITTER_SEEDS[frame] + element_id * 13)
    return rng.uniform(-max_deg, max_deg)


# === SVG Helpers ===

def svg_header(bg_top: str, bg_bot: str) -> str:
    return f'''<svg xmlns="http://www.w3.org/2000/svg" width="{WIDTH}" height="{HEIGHT}" viewBox="0 0 {WIDTH} {HEIGHT}">
  <defs>
    <linearGradient id="bg" x1="0" y1="0" x2="0" y2="1">
      <stop offset="0%" stop-color="{bg_top}"/>
      <stop offset="100%" stop-color="{bg_bot}"/>
    </linearGradient>
    <filter id="shadow" x="-5%" y="-5%" width="115%" height="115%">
      <feDropShadow dx="2" dy="3" stdDeviation="4" flood-opacity="0.15"/>
    </filter>
  </defs>
  <rect width="{WIDTH}" height="{HEIGHT}" fill="url(#bg)"/>'''


def svg_footer() -> str:
    return "</svg>"


def svg_rounded_rect(x: float, y: float, w: float, h: float,
                     rx: float = 20, fill: str = "#FFFFFF",
                     stroke: str = "#333333", stroke_width: float = 2,
                     opacity: float = 1.0, rotate: float = 0) -> str:
    transform = ""
    if rotate != 0:
        cx, cy = x + w / 2, y + h / 2
        transform = f' transform="rotate({rotate:.2f},{cx:.1f},{cy:.1f})"'
    return (f'  <rect x="{x:.1f}" y="{y:.1f}" width="{w:.1f}" height="{h:.1f}" '
            f'rx="{rx:.1f}" fill="{fill}" stroke="{stroke}" stroke-width="{stroke_width}" '
            f'opacity="{opacity:.3f}" filter="url(#shadow)"{transform}/>')


def svg_text(x: float, y: float, text: str, size: float = 48,
             fill: str = "#2D2D2D", anchor: str = "middle",
             weight: str = "bold", opacity: float = 1.0,
             rotate: float = 0, font: str = "sans-serif") -> str:
    transform = ""
    if rotate != 0:
        transform = f' transform="rotate({rotate:.2f},{x:.1f},{y:.1f})"'
    # Escape XML entities
    text = text.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;")
    return (f'  <text x="{x:.1f}" y="{y:.1f}" font-family="{font}" '
            f'font-size="{size:.1f}" font-weight="{weight}" fill="{fill}" '
            f'text-anchor="{anchor}" opacity="{opacity:.3f}"{transform}>{text}</text>')


def svg_sparkle(cx: float, cy: float, size: float = 12,
                fill: str = "#FFD700", opacity: float = 1.0) -> str:
    """Four-pointed sparkle star."""
    s = size
    points = [
        f"{cx},{cy - s}",
        f"{cx + s * 0.3},{cy - s * 0.3}",
        f"{cx + s},{cy}",
        f"{cx + s * 0.3},{cy + s * 0.3}",
        f"{cx},{cy + s}",
        f"{cx - s * 0.3},{cy + s * 0.3}",
        f"{cx - s},{cy}",
        f"{cx - s * 0.3},{cy - s * 0.3}",
    ]
    return (f'  <polygon points="{" ".join(points)}" '
            f'fill="{fill}" opacity="{opacity:.3f}"/>')


def svg_banana(cx: float, cy: float, size: float = 60,
               rotate: float = 0, opacity: float = 1.0) -> str:
    """A cute banana shape using arcs."""
    s = size
    return f'''  <g transform="translate({cx:.1f},{cy:.1f}) rotate({rotate:.1f}) scale({s/60:.2f})" opacity="{opacity:.3f}">
    <path d="M-25,-30 Q-35,0 -20,25 Q0,45 25,30 Q15,20 5,0 Q-5,-25 -25,-30Z"
          fill="{COLORS['banana_yellow']}" stroke="{COLORS['banana_brown']}" stroke-width="2"/>
    <path d="M-20,-28 Q-30,0 -15,22" fill="none" stroke="#FFF8A0" stroke-width="3" opacity="0.5"/>
    <ellipse cx="-22" cy="-32" rx="5" ry="3" fill="{COLORS['banana_brown']}"/>
  </g>'''


def svg_lightning(cx: float, cy: float, size: float = 40,
                  fill: str = "#FFA500", opacity: float = 1.0) -> str:
    """Lightning bolt."""
    s = size / 40
    return f'''  <g transform="translate({cx:.1f},{cy:.1f}) scale({s:.2f})" opacity="{opacity:.3f}">
    <polygon points="-5,-25 10,-5 2,-5 8,25 -10,0 -2,0" fill="{fill}" stroke="#CC8400" stroke-width="1.5"/>
  </g>'''


# === Scene Renderers ===

def scene_title(frame: int, local_frame: int, total_scene_frames: int) -> str:
    """Scene 1: Title card ‚Äî "gpal v0.4.1" bounces in."""
    t = local_frame / total_scene_frames  # 0..1 progress through scene
    parts = [svg_header(COLORS["bg_top_1"], COLORS["bg_bot_1"])]

    # Main title bounces down from top
    enter_t = ease_out_back(min(1.0, local_frame / 18))  # ~1.5s entrance
    title_y = lerp(-100, 420, enter_t)
    jx, jy = jitter(frame, 0)
    w = wobble(frame, 0, 0.8)
    parts.append(svg_text(540 + jx, title_y + jy, "gpal", size=140,
                          fill=COLORS["text_accent"], rotate=w))

    # Version slides in from right
    ver_enter = ease_out_back(min(1.0, max(0, (local_frame - 8)) / 18))
    ver_x = lerp(1200, 540, ver_enter)
    jx2, jy2 = jitter(frame, 1)
    parts.append(svg_text(ver_x + jx2, 530 + jy2, "v0.4.1", size=90,
                          fill=COLORS["text_dark"]))

    # Subtitle fades in
    sub_opacity = ease_in_out(min(1.0, max(0, (local_frame - 20)) / 12))
    jx3, jy3 = jitter(frame, 2)
    parts.append(svg_text(540 + jx3, 650 + jy3, "Model Upgrade Day!",
                          size=48, fill=COLORS["text_dark"],
                          opacity=sub_opacity, weight="normal"))

    # Sparkles appear after subtitle
    if local_frame > 24:
        sparkle_opacity = ease_in_out(min(1.0, (local_frame - 24) / 10))
        sparkle_positions = [
            (200, 300), (880, 280), (150, 700), (900, 680),
            (340, 200), (740, 750), (480, 180), (620, 800),
        ]
        for i, (sx, sy) in enumerate(sparkle_positions):
            phase = math.sin(frame * 0.4 + i * 1.2)  # pulsing
            s_size = 10 + 8 * (0.5 + 0.5 * phase)
            sjx, sjy = jitter(frame, 10 + i, 2)
            parts.append(svg_sparkle(sx + sjx, sy + sjy, s_size,
                                     opacity=sparkle_opacity * (0.5 + 0.5 * phase)))

    # Valentine heart (it's Valentine's Day!)
    if local_frame > 30:
        heart_opacity = ease_in_out(min(1.0, (local_frame - 30) / 10))
        hjx, hjy = jitter(frame, 20)
        bob = math.sin(frame * 0.3) * 5
        parts.append(f'  <text x="{540 + hjx:.1f}" y="{770 + bob + hjy:.1f}" '
                     f'font-size="50" text-anchor="middle" '
                     f'opacity="{heart_opacity:.3f}">üíù</text>')

    parts.append(svg_footer())
    return "\n".join(parts)


def scene_imagen(frame: int, local_frame: int, total_scene_frames: int) -> str:
    """Scene 2: Imagen Ultra upgrade card."""
    t = local_frame / total_scene_frames
    parts = [svg_header(COLORS["bg_top_2"], COLORS["bg_bot_2"])]

    # Scene title
    jx, jy = jitter(frame, 0)
    parts.append(svg_text(540 + jx, 120 + jy, "Imagen Ultra ‚ö°", size=64,
                          fill=COLORS["text_dark"]))

    # Old model card slides in from left
    card_enter = ease_out_back(min(1.0, local_frame / 15))
    card_x = lerp(-500, 140, card_enter)
    jx2, jy2 = jitter(frame, 1)
    w1 = wobble(frame, 1)

    # Card with old model name
    old_opacity = 1.0
    if local_frame > 30:
        old_opacity = max(0.2, 1.0 - ease_in_out((local_frame - 30) / 15))

    parts.append(svg_rounded_rect(card_x + jx2, 220 + jy2, 800, 120,
                                  rx=15, fill="#FFF0F0", stroke="#FFAAAA",
                                  opacity=old_opacity, rotate=w1))
    parts.append(svg_text(540 + jx2, 295 + jy2, "imagen-4.0-generate-001",
                          size=36, fill="#CC4444", opacity=old_opacity,
                          font="monospace"))

    # Strikethrough on old name
    if 25 < local_frame < 50:
        strike_t = ease_in_out(min(1.0, (local_frame - 25) / 8))
        sw = 800 * strike_t
        parts.append(f'  <line x1="{card_x + jx2 + 40:.1f}" y1="{283 + jy2:.1f}" '
                     f'x2="{card_x + jx2 + 40 + sw:.1f}" y2="{283 + jy2:.1f}" '
                     f'stroke="#CC4444" stroke-width="3" opacity="{old_opacity:.3f}"/>')

    # Arrow
    if local_frame > 20:
        arrow_opacity = ease_in_out(min(1.0, (local_frame - 20) / 10))
        ajx, ajy = jitter(frame, 3)
        parts.append(svg_text(540 + ajx, 420 + ajy, "‚Üì", size=72,
                              fill=COLORS["lightning"], opacity=arrow_opacity))

    # New model card slides up from bottom
    if local_frame > 25:
        new_enter = ease_out_back(min(1.0, (local_frame - 25) / 18))
        new_y = lerp(1200, 460, new_enter)
        jx4, jy4 = jitter(frame, 4)
        w2 = wobble(frame, 4)
        parts.append(svg_rounded_rect(140 + jx4, new_y + jy4, 800, 120,
                                      rx=15, fill="#F0FFF0", stroke="#88CC88",
                                      rotate=w2))
        parts.append(svg_text(540 + jx4, new_y + 75 + jy4,
                              "imagen-4.0-ultra-generate-001",
                              size=34, fill="#228B22", font="monospace"))

        # "ULTRA" badge
        if local_frame > 38:
            badge_t = ease_out_back(min(1.0, (local_frame - 38) / 10))
            badge_scale = badge_t
            bjx, bjy = jitter(frame, 5)
            parts.append(f'  <g transform="translate({820 + bjx:.1f},{new_y + 30 + bjy:.1f}) '
                         f'scale({badge_scale:.2f})">')
            parts.append(f'    <rect x="-40" y="-18" width="80" height="36" rx="18" '
                         f'fill="{COLORS["lightning"]}" stroke="#CC8400" stroke-width="1.5"/>')
            parts.append(f'    <text x="0" y="7" font-family="sans-serif" font-size="18" '
                         f'font-weight="bold" fill="white" text-anchor="middle">ULTRA</text>')
            parts.append('  </g>')

    # Lightning bolts decoration
    if local_frame > 15:
        bolt_opacity = ease_in_out(min(1.0, (local_frame - 15) / 10))
        for i, (bx, by) in enumerate([(120, 350), (960, 350), (120, 550), (960, 550)]):
            bjx, bjy = jitter(frame, 20 + i, 3)
            pulse = 0.7 + 0.3 * math.sin(frame * 0.5 + i)
            parts.append(svg_lightning(bx + bjx, by + bjy, 35 * pulse,
                                       opacity=bolt_opacity * pulse))

    # Floating sparkles
    for i in range(6):
        phase = math.sin(frame * 0.3 + i * 1.5)
        if phase > 0:
            sx = 100 + i * 160
            sy = 700 + 50 * math.sin(frame * 0.2 + i)
            sjx, sjy = jitter(frame, 30 + i)
            parts.append(svg_sparkle(sx + sjx, sy + sjy, 8 + 5 * phase,
                                     opacity=0.6 * phase))

    parts.append(svg_footer())
    return "\n".join(parts)


def scene_fast_tts(frame: int, local_frame: int, total_scene_frames: int) -> str:
    """Scene 3: Fast image gen + TTS cards."""
    t = local_frame / total_scene_frames
    parts = [svg_header(COLORS["bg_top_3"], COLORS["bg_bot_3"])]

    # Scene title
    jx, jy = jitter(frame, 0)
    parts.append(svg_text(540 + jx, 100 + jy, "New Capabilities", size=56,
                          fill=COLORS["text_dark"]))

    # Fast card slides in from left
    fast_enter = ease_out_back(min(1.0, local_frame / 18))
    fast_x = lerp(-600, 90, fast_enter)
    jx2, jy2 = jitter(frame, 1)
    w1 = wobble(frame, 1)
    parts.append(svg_rounded_rect(fast_x + jx2, 200 + jy2, 900, 180,
                                  rx=20, fill="#FFF8F0", stroke="#FFB366", rotate=w1))
    parts.append(svg_text(fast_x + 450 + jx2, 270 + jy2, "imagen-fast",
                          size=44, fill=COLORS["text_code"], font="monospace"))
    parts.append(svg_text(fast_x + 450 + jx2, 340 + jy2, "Quick image generation",
                          size=28, fill="#888888", weight="normal"))

    # Speed lines on fast card
    if local_frame > 10:
        for i in range(5):
            line_t = ((local_frame - 10 + i * 3) % 20) / 20
            lx = fast_x + 50 + line_t * 800
            ly = 230 + i * 30
            length = 40 + 20 * math.sin(frame * 0.5 + i)
            parts.append(f'  <line x1="{lx:.1f}" y1="{ly:.1f}" '
                         f'x2="{lx + length:.1f}" y2="{ly:.1f}" '
                         f'stroke="{COLORS["speed_line"]}" stroke-width="2" '
                         f'opacity="{0.3 + 0.2 * math.sin(frame * 0.4 + i):.3f}" '
                         f'stroke-linecap="round"/>')

    # "‚ö° FAST" badge
    if local_frame > 12:
        badge_t = ease_out_back(min(1.0, (local_frame - 12) / 10))
        bjx, bjy = jitter(frame, 3)
        bob = math.sin(frame * 0.4) * 3
        parts.append(f'  <g transform="translate({fast_x + 820 + bjx:.1f},'
                     f'{240 + bob + bjy:.1f}) scale({badge_t:.2f})">')
        parts.append(f'    <rect x="-35" y="-15" width="70" height="30" rx="15" '
                     f'fill="{COLORS["speed_line"]}" />')
        parts.append(f'    <text x="0" y="6" font-size="16" font-weight="bold" '
                     f'fill="white" text-anchor="middle" font-family="sans-serif">‚ö° FAST</text>')
        parts.append('  </g>')

    # TTS card slides in from right
    if local_frame > 15:
        tts_enter = ease_out_back(min(1.0, (local_frame - 15) / 18))
        tts_x = lerp(1200, 90, tts_enter)
        jx4, jy4 = jitter(frame, 4)
        w2 = wobble(frame, 4)
        parts.append(svg_rounded_rect(tts_x + jx4, 480 + jy4, 900, 180,
                                      rx=20, fill="#F0F0FF", stroke="#9999DD", rotate=w2))
        parts.append(svg_text(tts_x + 450 + jx4, 550 + jy4, "Pro TTS",
                              size=44, fill=COLORS["glow_tts"], font="monospace"))
        parts.append(svg_text(tts_x + 450 + jx4, 620 + jy4,
                              "Text-to-speech synthesis",
                              size=28, fill="#888888", weight="normal"))

        # Sound wave visualization
        if local_frame > 25:
            wave_opacity = ease_in_out(min(1.0, (local_frame - 25) / 10))
            for i in range(12):
                bar_h = 15 + 25 * abs(math.sin(frame * 0.6 + i * 0.8))
                bx = tts_x + 200 + i * 50
                by = 720 - bar_h / 2
                parts.append(f'  <rect x="{bx + jx4:.1f}" y="{by + jy4:.1f}" '
                             f'width="8" height="{bar_h:.1f}" rx="4" '
                             f'fill="{COLORS["glow_tts"]}" '
                             f'opacity="{wave_opacity * 0.7:.3f}"/>')

    # "üé§" microphone emoji
    if local_frame > 30:
        mic_opacity = ease_in_out(min(1.0, (local_frame - 30) / 8))
        mjx, mjy = jitter(frame, 6)
        bob = math.sin(frame * 0.35) * 4
        parts.append(f'  <text x="{160 + mjx:.1f}" y="{570 + bob + mjy:.1f}" '
                     f'font-size="60" opacity="{mic_opacity:.3f}">üé§</text>')

    # Decorative sparkles
    for i in range(4):
        phase = math.sin(frame * 0.35 + i * 2)
        if phase > 0:
            sx = 150 + i * 250
            sy = 900 + 30 * math.sin(frame * 0.2 + i)
            sjx, sjy = jitter(frame, 20 + i)
            parts.append(svg_sparkle(sx + sjx, sy + sjy, 8 + 4 * phase,
                                     opacity=0.5 * phase))

    parts.append(svg_footer())
    return "\n".join(parts)


def scene_banana(frame: int, local_frame: int, total_scene_frames: int) -> str:
    """Scene 4: Nano Banana with bouncing banana character."""
    t = local_frame / total_scene_frames
    parts = [svg_header(COLORS["bg_top_4"], COLORS["bg_bot_4"])]

    # Scene title
    jx, jy = jitter(frame, 0)
    parts.append(svg_text(540 + jx, 120 + jy, "Nano Banana üçå", size=60,
                          fill=COLORS["text_dark"]))

    # Model name card
    card_enter = ease_out_back(min(1.0, local_frame / 15))
    card_y = lerp(-200, 200, card_enter)
    jx2, jy2 = jitter(frame, 1)
    w1 = wobble(frame, 1)
    parts.append(svg_rounded_rect(140 + jx2, card_y + jy2, 800, 120,
                                  rx=20, fill="#FFFDE7", stroke="#FFD54F", rotate=w1))
    parts.append(svg_text(540 + jx2, card_y + 75 + jy2,
                          "nano-banana-pro-preview",
                          size=38, fill=COLORS["text_code"], font="monospace"))

    # Bouncing banana character
    bounce_y = abs(math.sin(frame * 0.4)) * 80
    banana_scale = 1.0 + 0.1 * math.sin(frame * 0.8)  # squash/stretch
    bjx, bjy = jitter(frame, 2, 2)
    banana_rot = math.sin(frame * 0.3) * 15 + wobble(frame, 2, 5)
    parts.append(svg_banana(540 + bjx, 550 - bounce_y + bjy,
                            size=80 * banana_scale, rotate=banana_rot))

    # Banana shadow (squishes when banana is high)
    shadow_scale = 1.0 - bounce_y / 200
    parts.append(f'  <ellipse cx="{540 + bjx:.1f}" cy="610" '
                 f'rx="{50 * shadow_scale:.1f}" ry="{10 * shadow_scale:.1f}" '
                 f'fill="#00000020"/>')

    # Cute face on banana (when it's close enough to see)
    face_y = 550 - bounce_y + bjy
    face_rot = banana_rot
    parts.append(f'  <g transform="translate({540 + bjx:.1f},{face_y - 5:.1f}) rotate({face_rot:.1f})">')
    # Eyes
    blink = 1.0 if (frame % 36) > 2 else 0.2  # blink every ~3 seconds
    parts.append(f'    <ellipse cx="-8" cy="-5" rx="4" ry="{5 * blink:.1f}" fill="#333"/>')
    parts.append(f'    <ellipse cx="12" cy="-5" rx="4" ry="{5 * blink:.1f}" fill="#333"/>')
    # Smile
    parts.append('    <path d="M-5,5 Q3,15 15,5" fill="none" stroke="#333" stroke-width="2"/>')
    # Blush
    parts.append('    <ellipse cx="-15" cy="5" rx="6" ry="4" fill="#FFB6C1" opacity="0.5"/>')
    parts.append('    <ellipse cx="22" cy="5" rx="6" ry="4" fill="#FFB6C1" opacity="0.5"/>')
    parts.append('  </g>')

    # Description cards
    if local_frame > 20:
        desc_enter = ease_out_back(min(1.0, (local_frame - 20) / 15))
        features = ["Best quality images", "Text rendering", "4K resolution"]
        for i, feat in enumerate(features):
            fx = lerp(1200, 540, desc_enter)
            fy = 700 + i * 60
            fjx, fjy = jitter(frame, 10 + i)
            delay_offset = i * 0.15
            feat_opacity = ease_in_out(min(1.0, max(0, (local_frame - 20 - i * 5)) / 10))
            parts.append(svg_text(fx + fjx, fy + fjy, f"‚ú¶ {feat}",
                                  size=30, fill=COLORS["text_dark"],
                                  opacity=feat_opacity, weight="normal"))

    # Floating mini bananas
    for i in range(6):
        phase = (frame * 0.15 + i * 1.3) % (2 * math.pi)
        bx = 100 + i * 170
        by = 400 + 60 * math.sin(phase)
        mini_rot = frame * 2 + i * 60
        mini_opacity = 0.3 + 0.2 * math.sin(phase)
        mjx, mjy = jitter(frame, 30 + i)
        parts.append(svg_banana(bx + mjx, by + mjy, size=20,
                                rotate=mini_rot % 360, opacity=mini_opacity))

    parts.append(svg_footer())
    return "\n".join(parts)


def scene_finale(frame: int, local_frame: int, total_scene_frames: int) -> str:
    """Scene 5: Kaizen message + model grid finale."""
    t = local_frame / total_scene_frames
    parts = [svg_header(
        lerp_color(COLORS["bg_top_5"], "#2D2D2D", t * 0.3),
        lerp_color(COLORS["bg_bot_5"], "#1a1a2e", t * 0.3)
    )]

    # Japanese text fades in
    jp_opacity = ease_in_out(min(1.0, local_frame / 18))
    jx, jy = jitter(frame, 0)
    parts.append(svg_text(540 + jx, 280 + jy,
                          "ÊîπÂñÑ„ÅÆÊóÖ„ÅØÁ∂ö„Åç„Åæ„Åô",
                          size=64, fill=lerp_color(COLORS["text_dark"], "#FFFFFF", t * 0.5),
                          opacity=jp_opacity))

    # Subtitle
    if local_frame > 10:
        sub_opacity = ease_in_out(min(1.0, (local_frame - 10) / 12))
        sjx, sjy = jitter(frame, 1)
        parts.append(svg_text(540 + sjx, 350 + sjy,
                              "The journey of improvement continues",
                              size=28,
                              fill=lerp_color("#888888", "#CCCCCC", t * 0.5),
                              weight="normal", opacity=sub_opacity))

    # Model cards grid
    if local_frame > 15:
        grid_enter = ease_out_back(min(1.0, (local_frame - 15) / 20))
        models = [
            ("Imagen Ultra", "#FF6B6B"),
            ("Imagen Fast", "#FFB366"),
            ("Pro TTS", "#7B68EE"),
            ("Nano Banana", "#FFE135"),
        ]
        grid_y = lerp(1100, 480, grid_enter)
        for i, (name, color) in enumerate(models):
            col = i % 2
            row = i // 2
            cx = 300 + col * 480
            cy = grid_y + row * 170
            gjx, gjy = jitter(frame, 10 + i)
            gw = wobble(frame, 10 + i, 0.5)

            # Mini card
            card_opacity = ease_in_out(min(1.0, max(0, (local_frame - 15 - i * 3)) / 10))
            parts.append(svg_rounded_rect(cx - 180 + gjx, cy - 50 + gjy, 360, 100,
                                          rx=15, fill="#FFFFFF20",
                                          stroke=color, stroke_width=2,
                                          opacity=card_opacity, rotate=gw))
            parts.append(svg_text(cx + gjx, cy + 12 + gjy, name,
                                  size=32, fill=color, opacity=card_opacity))

    # Sparkle burst
    if local_frame > 25:
        burst_t = (local_frame - 25) / (total_scene_frames - 25)
        num_sparkles = 16
        for i in range(num_sparkles):
            angle = (2 * math.pi * i / num_sparkles) + frame * 0.05
            radius = 80 + burst_t * 350
            sx = 540 + math.cos(angle) * radius
            sy = 540 + math.sin(angle) * radius
            phase = math.sin(frame * 0.5 + i * 0.7)
            s_size = 6 + 8 * max(0, phase)
            s_opacity = max(0, 0.8 - burst_t * 0.5) * max(0, phase)
            sjx, sjy = jitter(frame, 40 + i)
            parts.append(svg_sparkle(sx + sjx, sy + sjy, s_size,
                                     fill=lerp_color(COLORS["sparkle"], "#FFFFFF", burst_t * 0.5),
                                     opacity=s_opacity))

    # Heart for Valentine's Day
    if local_frame > 30:
        heart_opacity = ease_in_out(min(1.0, (local_frame - 30) / 10))
        hjx, hjy = jitter(frame, 50)
        bob = math.sin(frame * 0.3) * 5
        parts.append(f'  <text x="{540 + hjx:.1f}" y="{950 + bob + hjy:.1f}" '
                     f'font-size="40" text-anchor="middle" '
                     f'opacity="{heart_opacity:.3f}">üíù Happy Valentine\'s Day! üíù</text>')

    parts.append(svg_footer())
    return "\n".join(parts)


# === Frame Generation ===

# Scene boundaries (frame ranges, inclusive)
SCENES = [
    (0, 47, scene_title, 48),       # 0-4s
    (48, 107, scene_imagen, 60),    # 4-9s
    (108, 167, scene_fast_tts, 60), # 9-14s
    (168, 227, scene_banana, 60),   # 14-19s
    (228, TOTAL_FRAMES - 1, scene_finale, TOTAL_FRAMES - 228),  # 19-23s
]


def generate_svg(frame_num: int) -> str:
    """Generate SVG markup for a single frame."""
    for start, end, scene_fn, total in SCENES:
        if start <= frame_num <= end:
            return scene_fn(frame_num, frame_num - start, total)
    # Fallback: black frame
    return f'''<svg xmlns="http://www.w3.org/2000/svg" width="{WIDTH}" height="{HEIGHT}">
  <rect width="{WIDTH}" height="{HEIGHT}" fill="black"/>
</svg>'''


def render_single_frame(args: tuple[int, str]) -> int:
    """Render one frame: generate SVG, pipe to rsvg-convert, save PNG."""
    frame_num, output_dir = args
    svg = generate_svg(frame_num)
    png_path = os.path.join(output_dir, f"{frame_num:04d}.png")

    proc = subprocess.run(
        ["rsvg-convert", "--width", str(WIDTH), "--height", str(HEIGHT),
         "--format", "png", "--output", png_path],
        input=svg.encode("utf-8"),
        capture_output=True,
    )
    if proc.returncode != 0:
        print(f"  ‚úó Frame {frame_num}: {proc.stderr.decode()}", file=sys.stderr)
        return -1
    return frame_num


def render_frames(output_dir: str, total_frames: int) -> None:
    """Generate all frames in parallel."""
    os.makedirs(output_dir, exist_ok=True)

    tasks = [(i, output_dir) for i in range(total_frames)]
    workers = min(32, os.cpu_count() or 4)

    print(f"üé¨ Rendering {total_frames} frames using {workers} workers...")
    completed = 0
    errors = 0

    with ProcessPoolExecutor(max_workers=workers) as pool:
        futures = {pool.submit(render_single_frame, t): t[0] for t in tasks}
        for future in as_completed(futures):
            result = future.result()
            if result == -1:
                errors += 1
            else:
                completed += 1
            if completed % 50 == 0:
                print(f"  ‚úì {completed}/{total_frames} frames rendered")

    print(f"‚úÖ Rendered {completed} frames ({errors} errors)")
    if errors > 0:
        print("‚ö†Ô∏è  Some frames had errors ‚Äî check output above", file=sys.stderr)


def assemble_video(frames_dir: str, audio_path: str, output_path: str) -> None:
    """Use ffmpeg to combine frames + audio into mp4."""
    print(f"üé• Assembling video...")
    cmd = [
        "ffmpeg",
        "-framerate", str(FPS),
        "-i", f"{frames_dir}/%04d.png",
        "-i", audio_path,
        "-c:v", "libx264",
        "-pix_fmt", "yuv420p",
        "-c:a", "aac",
        "-shortest",
        "-y",
        output_path,
    ]
    proc = subprocess.run(cmd, capture_output=True, text=True)
    if proc.returncode != 0:
        print(f"‚úó ffmpeg failed:\n{proc.stderr}", file=sys.stderr)
        sys.exit(1)
    print(f"‚úÖ Video saved to {output_path}")


def main():
    print("üé¨ gpal v0.4.1 Stop Motion Animation Generator")
    print(f"   Resolution: {WIDTH}x{HEIGHT} @ {FPS}fps")
    print(f"   Frames: {TOTAL_FRAMES} ({DURATION}s)")
    print()

    frames_dir = str(FRAMES_DIR)
    render_frames(frames_dir, TOTAL_FRAMES)

    print()
    assemble_video(frames_dir, str(AUDIO_PATH), str(OUTPUT_PATH))

    print()
    print("üìä Checking output...")
    probe = subprocess.run(
        ["ffprobe", "-v", "quiet", "-show_entries",
         "format=duration,size", "-show_entries",
         "stream=width,height,codec_name,r_frame_rate",
         "-of", "json", str(OUTPUT_PATH)],
        capture_output=True, text=True,
    )
    if probe.returncode == 0:
        import json
        info = json.loads(probe.stdout)
        print(f"   {json.dumps(info, indent=2)}")

    print()
    print("üéâ Done! Watch your animation: gpal-v0.4.1.mp4")


if __name__ == "__main__":
    main()
